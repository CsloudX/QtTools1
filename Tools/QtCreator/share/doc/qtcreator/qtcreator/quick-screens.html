<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qtquick-screens.qdoc -->
  <title>Creating Screens | Qt Creator Manual</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="index.html">Qt Creator Manual</a></td><td >Creating Screens</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt Creator Manual 4.5.0</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="quick-scalable-image.html" />
  <link rel="next" href="qtquick-iso-icon-browser.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="quick-scalable-image.html">Creating Scalable Buttons and Borders</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="qtquick-iso-icon-browser.html">Browsing ISO 7000 Icons</a>
</p><p/>
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#adding-components-to-screens">Adding Components to Screens</a></li>
<li class="level1"><a href="#using-data-models">Using Data Models</a></li>
<li class="level1"><a href="#positioning-items-on-screens">Positioning Items on Screens</a></li>
<li class="level2"><a href="#setting-bindings">Setting Bindings</a></li>
<li class="level2"><a href="#setting-anchors-and-margins">Setting Anchors and Margins</a></li>
<li class="level2"><a href="#using-positioners">Using Positioners</a></li>
<li class="level2"><a href="#using-layouts">Using Layouts</a></li>
<li class="level2"><a href="#organizing-items">Organizing Items</a></li>
<li class="level1"><a href="#using-states">Using States</a></li>
<li class="level2"><a href="#using-scxml-state-machines">Using SCXML State Machines</a></li>
<li class="level1"><a href="#animating-screens">Animating Screens</a></li>
<li class="level1"><a href="#adding-user-interaction-methods">Adding User Interaction Methods</a></li>
<li class="level1"><a href="#implementing-application-logic">Implementing Application Logic</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Creating Screens</h1>
<span class="subtitle"></span>
<!-- $$$quick-screens.html-description -->
<div class="descr"> <a name="details"></a>
<p>You can use predefined QML types and your own components to create screens. Typically, the main QML file in a Qt Quick project specifies the main window of an application.</p>
<p>The QML files in the project folder are displayed in <b>QML Components</b> in the <b>Library</b>.</p>
<a name="adding-components-to-screens"></a>
<h2 id="adding-components-to-screens">Adding Components to Screens</h2>
<ol class="1" type="1"><li>Drag and drop components from the <b>Library</b> to the <b>Navigator</b> or <b>Form Editor</b>.</li>
<li>Select components in the <b>Navigator</b> to edit their properties in the <b>Properties</b> pane.<p>For example, you can anchor components to a position on the screen.</p>
</li>
</ol>
<p>For more information about the ready-made components available, see <a href="quick-components.html#using-qt-quick-controls">Using Qt Quick Controls</a>.</p>
<a name="using-data-models"></a>
<h2 id="using-data-models">Using Data Models</h2>
<p>You can create the following types of views to organize items provided by data models:</p>
<ul>
<li>Grid View provides a grid vizualization of a model.</li>
<li>List View provides a list vizualization of a model.</li>
<li>Path View visualizes the contents of a model along a path.</li>
</ul>
<p>When you add a Grid View, List View, or Path View, the ListModel and the delegate component that creates an instance for each item in the model are added automatically. You can edit item properties in the <b>Properties</b> pane or in the <b>Text Editor</b>. You can also replace the default model and delegate with other, more complex models and delegates in the <b>Text Editor</b>.</p>
<a name="positioning-items-on-screens"></a>
<h2 id="positioning-items-on-screens">Positioning Items on Screens</h2>
<p>The position of an item on the canvas can be either absolute or relative to other items. If you are designing a static user interface, manual positioning provides the most efficient form of positioning items on the screen. For a dynamic user interface, you can employ the following positioning methods provided by Qt Quick:</p>
<ul>
<li><a href="quick-screens.html#setting-bindings">Setting Bindings</a></li>
<li><a href="quick-screens.html#setting-anchors-and-margins">Setting Anchors and Margins</a></li>
<li><a href="quick-screens.html#using-positioners">Using Positioners</a></li>
<li><a href="quick-screens.html#using-layouts">Using Layouts</a></li>
<li><a href="quick-screens.html#organizing-items">Organizing Items</a></li>
</ul>
<a name="setting-bindings"></a>
<h3 >Setting Bindings</h3>
<p>Property binding is a declarative way of specifying the value of a property. Binding allows a property value to be expressed as a JavaScript expression that defines the value relative to other property values or data accessible in the application. The property value is automatically kept up to date if the other properties or data values change.</p>
<p>Property bindings are created implicitly in QML whenever a property is assigned a JavaScript expression. To set JavaScript expressions as values of properties in Qt Quick Designer, click the circle icon next to a property to open a context menu, and select <b>Set Binding</b>.</p>
<p class="centerAlign"><img src="images/qmldesigner-set-expression.png" alt="&quot;Type properties context menu&quot;" /></p><p>The <b>Binding Editor</b> supports code completion. Start typing a string and press <b>Ctrl+Space</b> to display a list of properties, IDs, and code snippets. When you enter a period (.) after a property name, a list of available values is displayed. Press <b>Enter</b> to accept the first suggestion in the list and to complete the code.</p>
<p class="centerAlign"><img src="images/qmldesigner-binding-editor.png" alt="&quot;Binding Editor&quot;" /></p><p>To remove bindings, select <b>Reset</b> in the context menu.</p>
<p>You can set bindings also in the <b>Connections</b> view. For more information, see <a href="qmldesigner-connections.html#adding-bindings-between-properties">Adding Bindings Between Properties</a>.</p>
<p>For more information on the JavaScript environment provided by QML, see Integrating QML and JavaScript.</p>
<p>Bindings are a black box for Qt Quick Designer and using them might have a negative impact on performance, so consider setting anchors and margins for items, instead. For example, instead of setting <code>parent.width</code> for an item, you could anchor the item to its sibling items on the left and the right.</p>
<a name="setting-anchors-and-margins"></a>
<h3 >Setting Anchors and Margins</h3>
<p>In an anchor-based layout, each QML type can be thought of as having a set of invisible <i>anchor</i> lines: top, bottom, left, right, fill, horizontal center, vertical center, and baseline.</p>
<p>In the <b>Layout</b> pane you can set anchors and margins for items. To set the anchors of an item, click the anchor buttons. You can combine the top/bottom, left/right, and horizontal/vertical anchors to anchor items in the corners of the parent item or center them horizontally or vertically within the parent item.</p>
<p class="centerAlign"><img src="images/qmldesigner-anchor-buttons.png" alt="&quot;Anchor buttons&quot;" /></p><p>For convenience, you can click the <img src="images/anchor_fill.png" alt="" /> (<b>Fill to Parent</b>) toolbar button to apply fill anchors to an item and the <img src="images/qtcreator-anchors-reset-icon.png" alt="" /> (<b>Reset Anchors</b>) button to reset the anchors to their saved state.</p>
<p>Specifying the baseline anchor in Qt Quick Designer is not supported. You can specify it in the <b>Text Editor</b>.</p>
<p>For performance reasons, you can only anchor an item to its siblings and direct parent. By default, an item is anchored to its parent when you use the anchor buttons. Select a sibling of the item in the <b>Target</b> field to anchor to it, instead.</p>
<p>Arbitrary anchoring is not supported. For example, you cannot specify: <code>anchor.left: parent.right</code>. You have to specify: <code>anchor.left: parent.left</code>. When you use the anchor buttons, anchors to the parent item are always specified to the same side. However, anchors to sibling items are specified to the opposite side: <code>anchor.left: sibling.right</code>. This allows you to keep sibling items together.</p>
<p>In the following image, <b>Rectangle 2</b> is anchored to <b>Rectangle 1</b> on its left and to the bottom of its parent.</p>
<p class="centerAlign"><img src="images/qmldesigner-anchors.png" alt="&quot;Anchoring sibling items&quot;" /></p><p>The anchors for <b>Rectangle 2</b> are specified as follows in code:</p>
<pre class="qml">

  <span class="type">Rectangle</span> {
      <span class="name">id</span>: <span class="name">rectangle2</span>
      <span class="name">anchors</span>.left: <span class="name">rectangle1</span>.<span class="name">right</span>
      <span class="name">anchors</span>.leftMargin: <span class="number">15</span>
      <span class="name">anchors</span>.bottom: <span class="name">parent</span>.<span class="name">bottom</span>
      <span class="name">anchors</span>.bottomMargin: <span class="number">15</span>
      //
  }

</pre>
<p>Margins specify the amount of empty space to leave to the outside of an item. Margins only have meaning for anchors. They do not take any effect when using other layouts or absolute positioning.</p>
<a name="using-positioners"></a>
<h3 >Using Positioners</h3>
<p>Positioner items are container items that manage the positions of items in a declarative user interface. Positioners behave in a similar way to the layout managers used with standard Qt widgets, except that they are also containers in their own right.</p>
<p>You can use the following positioners to arrange items on screens:</p>
<ul>
<li>Column arranges its child items vertically.</li>
<li>Row arranges its child items horizontally.</li>
<li>Grid arranges its child items so that they are aligned in a grid and are not overlapping.</li>
<li>Flow arranges its child items side by side, wrapping as necessary.</li>
</ul>
<p>To lay out several items in a <b>Column</b>, <b>Row</b>, <b>Grid</b>, or <b>Flow</b>, select the items on the canvas, and then select <b>Layout</b> in the context menu.</p>
<a name="using-layouts"></a>
<h3 >Using Layouts</h3>
<p>From Qt 5.1, you can use QML types in the Qt Quick Layouts module to arrange Qt Quick items on screens. Unlike positioners, they manage both the positions and sizes of items in a declarative interface. They are well suited for resizable user interfaces.</p>
<p>You can use the following layout types to arrange items on screens:</p>
<ul>
<li>Layout provides attached properties for items pushed onto a <b>Column Layout</b>, <b>Row Layout</b>, or <b>Grid Layout</b>.</li>
<li>Column Layout provides a grid layout with only one column.</li>
<li>Row Layout provides a grid layout with only one row.</li>
<li>Grid Layout provides a way of dynamically arranging items in a grid.</li>
<li>Stack Layout provides a stack of items where only one item is visible at a time.</li>
</ul>
<p>To lay out several items in a <b>Column Layout</b>, <b>Row Layout</b>, <b>Grid Layout</b>, or <b>Stack Layout</b>, select the items in the <b>Form Editor</b>, and then select <b>Layout</b> in the context menu.</p>
<p>You can also click the <img src="images/column.png" alt="" /> (<b>Column Layout</b>), <img src="images/row.png" alt="" /> (<b>Row Layout</b>), and <img src="images/grid.png" alt="" /> (<b>Grid Layout</b>) toolbar buttons to apply layouts to the selected items.</p>
<p>To make an item within a layout as wide as possible while respecting the given constraints, select the item on the canvas and then select <b>Layout</b> &gt; <b>Fill Width</b> in the context menu. To make the item as high as possible, select <b>Fill Height</b>.</p>
<a name="editing-stack-layouts"></a>
<h4 >Editing Stack Layouts</h4>
<p class="centerAlign"><img src="images/qtquick-designer-stacked-view.png" alt="" /></p><p>To add items to a <b>Stack Layout</b>, select the <img src="images/plus.png" alt="" /> button next to the type name in the <b>Form Editor</b>. To move between items, select the <img src="images/prev.png" alt="" /> (<b>Previous</b>) and <img src="images/next.png" alt="" /> (<b>Next</b>) buttons.</p>
<p>To add a tab bar to a stack layout, select <b>Stacked Container</b> &gt; <b>Add Tab Bar</b>.</p>
<p>To raise or lower the stacking order of an item, select <b>Stacked Container</b> &gt; <b>Increase Index</b> or <b>Decrease Index</b>.</p>
<a name="organizing-items"></a>
<h3 >Organizing Items</h3>
<p>From Qt 5.7, you can use the following Qt Quick Controls 2 types to organize items on screens:</p>
<ul>
<li>Frame places a logical group of controls within a visual frame.</li>
<li>Group Box is used to lay out a logical group of controls together, within a titled visual frame.</li>
<li><a href="creator-project-wizards-json.html#label">Label</a> is a text label with inherited styling and font.</li>
<li>Page Indicator indicates the currently active page.</li>
<li>Pane provides a background matching with the application style and theme.</li>
</ul>
<a name="using-states"></a>
<h2 id="using-states">Using States</h2>
<p>Use states and transitions to navigate between screens.</p>
<p>QML states typically describe user interface configurations, such as the UI controls, their properties and behavior and the available actions. For example, you can use states to create two screens.</p>
<p>To add states, click the empty slot in the <b>States</b> pane. Then modify the new state in the <b>Form Editor</b> or the <b>Properties</b> pane.</p>
<p class="centerAlign"><img src="images/qmldesigner-states.png" alt="&quot;States pane&quot;" /></p><p>The properties that you change in a state are highlighted with blue color. In the <b>Text Editor</b>, you can see the changes recorded as changes to the base state.</p>
<p>To keep the QML code clean, you should create a base state that contains all the types you will need in the application. You can then create states, in which you hide and show a set of items and modify their properties. This allows you to:</p>
<ul>
<li>Align items on different screens with each other.</li>
<li>Avoid excessive property changes. If an item is invisible in the base state, you must define all changes to its child types as property changes, which leads to complicated QML code.</li>
<li>Minimize the differences between the base state and the other states to keep the QML code short and readable and to improve performance.</li>
<li>Avoid problems when using transitions and animation when changing states.</li>
</ul>
<p>To create screens for an application by using states:</p>
<ol class="1" type="1"><li>In the base state, add all items you will need in the application (1). While you work on one screen, you can click the <img src="images/eye_open.png" alt="" /> icon to hide items on the canvas that are not part of a screen.</li>
<li>In the <b>States</b> pane, click the empty slot to create a new state and give it a name. For example, <code>Normal</code>.</li>
<li>In the <b>Properties</b> pane (2), deselect the <b>Visibility</b> check box or set <b>Opacity</b> to 0 for each item that is not needed in this view. If you specify the setting for the parent item, all child items inherit it and are also hidden.<p class="centerAlign"><img src="images/qmldesigner-screen-design.png" alt="&quot;Designing screens&quot;" /></p></li>
<li>Create additional states for each screen and set the visibility or opacity of the items in the screen.</li>
<li>To determine which view opens when the application starts, use the <b>Text Editor</b> to set the state of the root item of the .qml file, as specified by the following code snippet:<pre class="qml">

  <span class="type">Item</span> {
      <span class="name">state</span>: <span class="string">&quot;Normal&quot;</span>
  }

</pre>
</li>
</ol>
<a name="using-scxml-state-machines"></a>
<h3 >Using SCXML State Machines</h3>
<p>To use QML and Qt Quick Designer together with an SCXML state machine, add states and bind them to the state machine in the <b>Backends</b> tab, as described in <a href="qmldesigner-connections.html#managing-c-backend-objects">Managing C++ Backend Objects</a>.</p>
<p>In the <b>States</b> pane, you can edit the <code>when</code> condition of states to map QML states to the states of the SCXML state machine. For an example, see Qt SCXML Traffic Light QML Example (Dynamic).</p>
<p class="centerAlign"><img src="images/qmldesigner-states-when-condition.png" alt="" /></p><a name="animating-screens"></a>
<h2 id="animating-screens">Animating Screens</h2>
<p>To make movement between states smooth, you can specify transitions. You can use different types of animated transitions. For example, you can animate changes to property values and colors. You can use rotation animation to control the direction of rotation. For more information, see Animation and Transitions in Qt Quick.</p>
<p>You can use the <code>ParallelAnimation</code> type to start several animations at the same time. Or use the <code>SequentialAnimation</code> type to run them one after another.</p>
<p>You can use the <b>Text Editor</b> to specify transitions. For more information, see Transition.</p>
<a name="adding-user-interaction-methods"></a>
<h2 id="adding-user-interaction-methods">Adding User Interaction Methods</h2>
<p>You can use the following QML types to add basic interaction methods to screens:</p>
<ul>
<li>Flickable items can be flicked horizontally or vertically.</li>
<li>Focus Scope assists in keyboard focus handling when building reusable QML components.</li>
<li>Mouse Area enables simple mouse handling.</li>
</ul>
<p>Since Qt 5.7, you can also use the following Qt Quick Controls 2 types to inform users about the progress of the application or to gather input from the user:</p>
<ul>
<li>Busy Indicator indicates activity while content is being loaded.</li>
<li>Button provides a push button that you can associate with an action.</li>
<li>Check Box provides an option button that can be toggled on (checked) or off (unchecked).</li>
<li>Check Delegate presents an item delegate that can be toggled on (checked) or off (unchecked).</li>
<li>Combo Box is a combined button and popup list that is populated by using a data model.</li>
<li>Dial is a circular dial that is rotated to set a value.</li>
<li>Item Delegate is a standard view item that can be used in various views and controls.</li>
<li>Progress Bar indicates the progress of an operation.</li>
<li>Radio Button provides an option button that can be switched on (checked) or off (unchecked).</li>
<li>Radio Delegate presents an item delegate that can be toggled on (checked) or off (unchecked).</li>
<li>Slider selects a value by sliding a handle along a track.</li>
<li>Spin Box enables the user to specify a value by clicking the up or down buttons, by pressing up or down on the keyboard, or by entering a value in the box.</li>
<li>Switch is an option button that can be toggled on or off.</li>
<li>Text Area displays multiple lines of editable formatted text.</li>
<li>Text Field displays a single line of editable plain text.</li>
<li>Tool Bar is a container of application-wide and context sensitive actions and controls, such as navigation buttons and search fields.</li>
<li>Tool Button is a button that is functionally similar to <b>Button</b>, but provides a look that is more suitable for a <b>Tool Bar</b>.</li>
<li>Tumbler is a spinnable wheel of items that can be selected.</li>
</ul>
<a name="implementing-application-logic"></a>
<h2 id="implementing-application-logic">Implementing Application Logic</h2>
<p>A user interface is only a part of an application, and not really useful by itself. You can use Qt or JavaScript to implement the application logic. For more information on using JavaScript, see Integrating QML and JavaScript.</p>
<p>For an example of how to use JavaScript to develop a game, see the QML Advanced Tutorial.</p>
</div>
<!-- @@@quick-screens.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="quick-scalable-image.html">Creating Scalable Buttons and Borders</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="qtquick-iso-icon-browser.html">Browsing ISO 7000 Icons</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2017 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
