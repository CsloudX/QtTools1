<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- pluginmanager.cpp -->
  <title>PluginManager Class | Extending Qt Creator Manual</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="extending-index.html">Extending Qt Creator Manual</a></td><td >PluginManager</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Extending Qt Creator Manual 4.5.0</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#plugins">Plugins</a></li>
<li class="level2"><a href="#object-pool">Object Pool</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">PluginManager Class</h1>
<span class="small-subtitle">(<a href="extensionsystem-pluginmanager.html">ExtensionSystem::PluginManager</a>)<br/></span>
<!-- $$$PluginManager-brief -->
<p>The <a href="extensionsystem-pluginmanager.html">PluginManager</a> class implements the core plugin system that manages the plugins, their life cycle, and their registered objects. <a href="#details">More...</a></p>
<!-- @@@PluginManager -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;PluginManager&gt;</span>
</td></tr></table></div><ul>
<li><a href="extensionsystem-pluginmanager-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#PluginManager">PluginManager</a></b>()</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a></b>(QObject *<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QObject *&gt; </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#allObjects">allObjects</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#getObject">getObject</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#getObject-1">getObject</a></b>(Predicate <i>predicate</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#getObjectByClassName">getObjectByClassName</a></b>(const QString &amp;<i>className</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#getObjectByName">getObjectByName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T *&gt; </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#getObjects">getObjects</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T *&gt; </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#getObjects-1">getObjects</a></b>(Predicate <i>predicate</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> PluginManager *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#instance">instance</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QReadWriteLock *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#listLock">listLock</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#loadPlugins">loadPlugins</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;PluginSpec *&gt; </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#loadQueue">loadQueue</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#pluginIID">pluginIID</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#pluginPaths">pluginPaths</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QList&lt;PluginSpec *&gt; </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#plugins">plugins</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#removeObject">removeObject</a></b>(QObject *<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#setPluginIID">setPluginIID</a></b>(const QString &amp;<i>iid</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$PluginManager-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The <a href="extensionsystem-pluginmanager.html">PluginManager</a> class implements the core plugin system that manages the plugins, their life cycle, and their registered objects.</p>
<p>The plugin manager is used for the following tasks:</p>
<ul>
<li>Manage plugins and their state</li>
<li>Manipulate a 'common object pool'</li>
</ul>
<a name="plugins"></a>
<h3 >Plugins</h3>
<p>Plugins consist of an XML descriptor file, and of a library that contains a Qt plugin that must derive from the <a href="extensionsystem-iplugin.html">IPlugin</a> class and has an IID of <code>&quot;org.qt-project.Qt.QtCreatorPlugin&quot;</code>. The plugin manager is used to set a list of file system directories to search for plugins, retrieve information about the state of these plugins, and to load them.</p>
<p>Usually, the application creates a <a href="extensionsystem-pluginmanager.html">PluginManager</a> instance and initiates the loading.</p>
<pre class="cpp">

  <span class="comment">// 'plugins' and subdirs will be searched for plugins</span>
  PluginManager<span class="operator">::</span>setPluginPaths(<span class="type">QStringList</span>(<span class="string">&quot;plugins&quot;</span>));
  PluginManager<span class="operator">::</span>loadPlugins(); <span class="comment">// try to load all the plugins</span>

</pre>
<p>Additionally, it is possible to directly access the plugin specifications (the information in the descriptor file), the plugin instances (via <a href="extensionsystem-pluginspec.html">PluginSpec</a>), and their state.</p>
<a name="object-pool"></a>
<h3 >Object Pool</h3>
<p>Plugins (and everybody else) can add objects to a common 'pool' that is located in the plugin manager. Objects in the pool must derive from QObject, there are no other prerequisites. All objects of a specified type can be retrieved from the object pool via the <a href="extensionsystem-pluginmanager.html#getObjects">getObjects</a>() and <a href="extensionsystem-pluginmanager.html#getObject">getObject</a>() functions.</p>
<p>Whenever the state of the object pool changes a corresponding signal is emitted by the plugin manager.</p>
<p>A common usecase for the object pool is that a plugin (or the application) provides an &quot;extension point&quot; for other plugins, which is a class / interface that can be implemented and added to the object pool. The plugin that provides the extension point looks for implementations of the class / interface in the object pool.</p>
<pre class="cpp">

  <span class="comment">// Plugin A provides a &quot;MimeTypeHandler&quot; extension point</span>
  <span class="comment">// in plugin B:</span>
  MyMimeTypeHandler <span class="operator">*</span>handler <span class="operator">=</span> <span class="keyword">new</span> MyMimeTypeHandler();
  PluginManager<span class="operator">::</span>instance()<span class="operator">-</span><span class="operator">&gt;</span>addObject(handler);
  <span class="comment">// In plugin A:</span>
  <span class="type">QList</span><span class="operator">&lt;</span>MimeTypeHandler <span class="operator">*</span><span class="operator">&gt;</span> mimeHandlers <span class="operator">=</span>
      PluginManager<span class="operator">::</span>getObjects<span class="operator">&lt;</span>MimeTypeHandler<span class="operator">&gt;</span>();

</pre>
<p>The <code>ExtensionSystem::Invoker</code> class template provides &quot;syntactic sugar&quot; for using &quot;soft&quot; extension points that may or may not be provided by an object in the pool. This approach does neither require the &quot;user&quot; plugin being linked against the &quot;provider&quot; plugin nor a common shared header file. The exposed interface is implicitly given by the invokable functions of the &quot;provider&quot; object in the object pool.</p>
<p>The <code>ExtensionSystem::invoke</code> function template encapsulates {<a href="extensionsystem-invoker.html">ExtensionSystem::Invoker</a>} construction for the common case where the success of the call is not checked.</p>
<pre class="cpp">

  <span class="comment">// In the &quot;provide&quot; plugin A:</span>
  <span class="keyword">namespace</span> PluginA {
  <span class="keyword">class</span> SomeProvider : <span class="keyword">public</span> <span class="type">QObject</span>
  {
      Q_OBJECT

  <span class="keyword">public</span>:
      Q_INVOKABLE <span class="type">QString</span> doit(<span class="keyword">const</span> <span class="type">QString</span> <span class="operator">&amp;</span>msg<span class="operator">,</span> <span class="type">int</span> n) {
      {
          qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;I AM DOING IT &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> msg;
          <span class="keyword">return</span> <span class="type">QString</span><span class="operator">::</span>number(n);
      }
  };
  } <span class="comment">// namespace PluginA</span>


  <span class="comment">// In the &quot;user&quot; plugin B:</span>
  <span class="type">int</span> someFuntionUsingPluginA()
  {
      <span class="keyword">using</span> <span class="keyword">namespace</span> ExtensionSystem;

      <span class="type">QObject</span> <span class="operator">*</span>target <span class="operator">=</span> PluginManager<span class="operator">::</span>getObjectByClassName(<span class="string">&quot;PluginA::SomeProvider&quot;</span>);

      <span class="keyword">if</span> (target) {
          <span class="comment">// Some random argument.</span>
          <span class="type">QString</span> msg <span class="operator">=</span> <span class="string">&quot;REALLY.&quot;</span>;

          <span class="comment">// Plain function call, no return value.</span>
          invoke<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;</span>(target<span class="operator">,</span> <span class="string">&quot;doit&quot;</span><span class="operator">,</span> msg<span class="operator">,</span> <span class="number">2</span>);

          <span class="comment">// Plain function with no return value.</span>
          qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Result: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> invoke<span class="operator">&lt;</span><span class="type">QString</span><span class="operator">&gt;</span>(target<span class="operator">,</span> <span class="string">&quot;doit&quot;</span><span class="operator">,</span> msg<span class="operator">,</span> <span class="number">21</span>);

          <span class="comment">// Record success of function call with return value.</span>
          Invoker<span class="operator">&lt;</span><span class="type">QString</span><span class="operator">&gt;</span> in1(target<span class="operator">,</span> <span class="string">&quot;doit&quot;</span><span class="operator">,</span> msg<span class="operator">,</span> <span class="number">21</span>);
          qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Success: (expected)&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> in1<span class="operator">.</span>wasSuccessful();

          <span class="comment">// Try to invoke a non-existing function.</span>
          Invoker<span class="operator">&lt;</span><span class="type">QString</span><span class="operator">&gt;</span> in2(target<span class="operator">,</span> <span class="string">&quot;doitWrong&quot;</span><span class="operator">,</span> msg<span class="operator">,</span> <span class="number">22</span>);
          qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Success (not expected):&quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> in2<span class="operator">.</span>wasSuccessful();

      } <span class="keyword">else</span> {

          <span class="comment">// We have to cope with plugin A's absence.</span>
      }
  };

</pre>
<p><b>Note: </b>The type of the parameters passed to the <code>invoke()</code> calls is deduced from the parameters themselves and must match the type of the arguments of the called functions <i>exactly</i>. No conversion or even integer promotions are applicable, so to invoke a function with a <code>long</code> parameter explicitly use <code>long(43)</code> or such.</p><p><b>Note: </b>The object pool manipulating functions are thread-safe.</p></div>
<!-- @@@PluginManager -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$PluginManager[overload1]$$$PluginManager -->
<h3 class="fn" id="PluginManager"><a name="PluginManager"></a>PluginManager::<span class="name">PluginManager</span>()</h3>
<p>Creates a plugin manager. Should be done only once per application.</p>
<!-- @@@PluginManager -->
<!-- $$$addObject[overload1]$$$addObjectQObject* -->
<h3 class="fn" id="addObject"><a name="addObject"></a><code>[static] </code><span class="type">void</span> PluginManager::<span class="name">addObject</span>(<span class="type">QObject</span> *<i>obj</i>)</h3>
<p>Adds the object <i>obj</i> to the object pool, so it can be retrieved again from the pool by type.</p>
<p>The plugin manager does not do any memory management - added objects must be removed from the pool and deleted manually by whoever is responsible for the object.</p>
<p>Emits the objectAdded() signal.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#removeObject">PluginManager::removeObject</a>(), <a href="extensionsystem-pluginmanager.html#getObject">PluginManager::getObject</a>(), and <a href="extensionsystem-pluginmanager.html#getObjects">PluginManager::getObjects</a>().</p>
<!-- @@@addObject -->
<!-- $$$allObjects[overload1]$$$allObjects -->
<h3 class="fn" id="allObjects"><a name="allObjects"></a><code>[static] </code><span class="type">QList</span>&lt;<span class="type">QObject</span> *&gt; PluginManager::<span class="name">allObjects</span>()</h3>
<p>Retrieves the list of all objects in the pool, unfiltered.</p>
<p>Usually, clients do not need to call this function.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#getObject">PluginManager::getObject</a>() and <a href="extensionsystem-pluginmanager.html#getObjects">PluginManager::getObjects</a>().</p>
<!-- @@@allObjects -->
<!-- $$$getObject[overload1]$$$getObject -->
<h3 class="fn" id="getObject"><a name="getObject"></a><code>[static] </code><span class="type">T</span> *PluginManager::<span class="name">getObject</span>()</h3>
<p>Retrieves the object of a given type from the object pool.</p>
<p>This function uses <code>qobject_cast</code> to determine the type of an object. If there are more than one object of the given type in the object pool, this function will arbitrarily choose one of them.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a>().</p>
<!-- @@@getObject -->
<!-- $$$getObject$$$getObjectPredicate -->
<h3 class="fn" id="getObject-1"><a name="getObject-1"></a><code>[static] </code><span class="type">T</span> *PluginManager::<span class="name">getObject</span>(<span class="type">Predicate</span> <i>predicate</i>)</h3>
<p>Retrieves the object of a given type from the object pool that matches the <i>predicate</i>.</p>
<p>This function uses <code>qobject_cast</code> to determine the type of an object. The predicate must be a function taking T * and returning a bool. If there is more than one object matching the type and predicate, this function will arbitrarily choose one of them.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a>().</p>
<!-- @@@getObject -->
<!-- $$$getObjectByClassName[overload1]$$$getObjectByClassNameconstQString& -->
<h3 class="fn" id="getObjectByClassName"><a name="getObjectByClassName"></a><code>[static] </code><span class="type">QObject</span> *PluginManager::<span class="name">getObjectByClassName</span>(const <span class="type">QString</span> &amp;<i>className</i>)</h3>
<p>Retrieves one object inheriting a class with <i>className</i> from the object pool.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a>().</p>
<!-- @@@getObjectByClassName -->
<!-- $$$getObjectByName[overload1]$$$getObjectByNameconstQString& -->
<h3 class="fn" id="getObjectByName"><a name="getObjectByName"></a><code>[static] </code><span class="type">QObject</span> *PluginManager::<span class="name">getObjectByName</span>(const <span class="type">QString</span> &amp;<i>name</i>)</h3>
<p>Retrieves one object with <i>name</i> from the object pool.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a>().</p>
<!-- @@@getObjectByName -->
<!-- $$$getObjects[overload1]$$$getObjects -->
<h3 class="fn" id="getObjects"><a name="getObjects"></a><code>[static] </code><span class="type">QList</span>&lt;<span class="type">T</span> *&gt; PluginManager::<span class="name">getObjects</span>()</h3>
<p>Retrieves all objects of a given type from the object pool.</p>
<p>This function uses <code>qobject_cast</code> to determine the type of an object.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a>().</p>
<!-- @@@getObjects -->
<!-- $$$getObjects$$$getObjectsPredicate -->
<h3 class="fn" id="getObjects-1"><a name="getObjects-1"></a><code>[static] </code><span class="type">QList</span>&lt;<span class="type">T</span> *&gt; PluginManager::<span class="name">getObjects</span>(<span class="type">Predicate</span> <i>predicate</i>)</h3>
<p>Retrieves all objects of a given type from the object pool that match the <i>predicate</i>.</p>
<p>This function uses <code>qobject_cast</code> to determine the type of an object. The predicate should be a unary function taking a T* parameter and returning a bool.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">addObject</a>().</p>
<!-- @@@getObjects -->
<!-- $$$instance[overload1]$$$instance -->
<h3 class="fn" id="instance"><a name="instance"></a><code>[static] </code><span class="type"><a href="extensionsystem-pluginmanager.html#PluginManager">PluginManager</a></span> *PluginManager::<span class="name">instance</span>()</h3>
<p>Gets the unique plugin manager instance.</p>
<!-- @@@instance -->
<!-- $$$listLock[overload1]$$$listLock -->
<h3 class="fn" id="listLock"><a name="listLock"></a><code>[static] </code><span class="type">QReadWriteLock</span> *PluginManager::<span class="name">listLock</span>()</h3>
<!-- @@@listLock -->
<!-- $$$loadPlugins[overload1]$$$loadPlugins -->
<h3 class="fn" id="loadPlugins"><a name="loadPlugins"></a><code>[static] </code><span class="type">void</span> PluginManager::<span class="name">loadPlugins</span>()</h3>
<p>Tries to load all the plugins that were previously found when setting the plugin search paths. The plugin specs of the plugins can be used to retrieve error and state information about individual plugins.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a>() and <a href="extensionsystem-pluginmanager.html#plugins">plugins</a>().</p>
<!-- @@@loadPlugins -->
<!-- $$$loadQueue[overload1]$$$loadQueue -->
<h3 class="fn" id="loadQueue"><a name="loadQueue"></a><code>[static] </code><span class="type">QList</span>&lt;<span class="type"><a href="extensionsystem-pluginspec.html">PluginSpec</a></span> *&gt; PluginManager::<span class="name">loadQueue</span>()</h3>
<p>Returns a list of plugins in load order.</p>
<!-- @@@loadQueue -->
<!-- $$$pluginIID[overload1]$$$pluginIID -->
<h3 class="fn" id="pluginIID"><a name="pluginIID"></a><code>[static] </code><span class="type">QString</span> PluginManager::<span class="name">pluginIID</span>()</h3>
<p>The IID that valid plugins must have.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#setPluginIID">setPluginIID</a>().</p>
<!-- @@@pluginIID -->
<!-- $$$pluginPaths[overload1]$$$pluginPaths -->
<h3 class="fn" id="pluginPaths"><a name="pluginPaths"></a><code>[static] </code><span class="type">QStringList</span> PluginManager::<span class="name">pluginPaths</span>()</h3>
<p>The list of paths were the plugin manager searches for plugins.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a>().</p>
<!-- @@@pluginPaths -->
<!-- $$$plugins[overload1]$$$plugins -->
<h3 class="fn" id="plugins"><a name="plugins"></a><code>[static] </code>const <span class="type">QList</span>&lt;<span class="type"><a href="extensionsystem-pluginspec.html">PluginSpec</a></span> *&gt; PluginManager::<span class="name">plugins</span>()</h3>
<p>List of all plugin specifications that have been found in the plugin search paths. This list is valid directly after the <a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a>() call. The plugin specifications contain the information from the plugins' xml description files and the current state of the plugins. If a plugin's library has been already successfully loaded, the plugin specification has a reference to the created plugin instance as well.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a>().</p>
<!-- @@@plugins -->
<!-- $$$removeObject[overload1]$$$removeObjectQObject* -->
<h3 class="fn" id="removeObject"><a name="removeObject"></a><code>[static] </code><span class="type">void</span> PluginManager::<span class="name">removeObject</span>(<span class="type">QObject</span> *<i>obj</i>)</h3>
<p>Emits aboutToRemoveObject() and removes the object <i>obj</i> from the object pool.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">PluginManager::addObject</a>().</p>
<!-- @@@removeObject -->
<!-- $$$setPluginIID[overload1]$$$setPluginIIDconstQString& -->
<h3 class="fn" id="setPluginIID"><a name="setPluginIID"></a><code>[static] </code><span class="type">void</span> PluginManager::<span class="name">setPluginIID</span>(const <span class="type">QString</span> &amp;<i>iid</i>)</h3>
<p>Sets the IID that valid plugins must have. Only plugins with this IID are loaded, others are silently ignored.</p>
<p>At the moment this must be called before <a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a>() is called. // ### TODO let this + <a href="extensionsystem-pluginmanager.html#setPluginPaths">setPluginPaths</a> read the plugin meta data lazyly whenever <a href="extensionsystem-pluginmanager.html#loadPlugins">loadPlugins</a>() or <a href="extensionsystem-pluginmanager.html#plugins">plugins</a>() is called.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#pluginIID">pluginIID</a>().</p>
<!-- @@@setPluginIID -->
<!-- $$$setPluginPaths[overload1]$$$setPluginPathsconstQStringList& -->
<h3 class="fn" id="setPluginPaths"><a name="setPluginPaths"></a><code>[static] </code><span class="type">void</span> PluginManager::<span class="name">setPluginPaths</span>(const <span class="type">QStringList</span> &amp;<i>paths</i>)</h3>
<p>Sets the plugin search paths, i.e&#x2e; the file system paths where the plugin manager looks for plugin descriptions. All given <i>paths</i> and their sub directory trees are searched for plugin xml description files.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#pluginPaths">pluginPaths</a>() and <a href="extensionsystem-pluginmanager.html#loadPlugins">loadPlugins</a>().</p>
<!-- @@@setPluginPaths -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2017 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
