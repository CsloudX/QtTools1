<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- rule.qdoc -->
  <title>Rule Item | Qbs Manual</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="index.html">Qbs Manual</a></td><td >Rule Item</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qbs 1.10.0</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
  <link rel="prev" href="propertyoptions-item.html" />
  <link rel="next" href="scanner-item.html" />
<p class="naviNextPrevious headerNavi">
<a class="prevPage" href="propertyoptions-item.html">PropertyOptions Item</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="scanner-item.html">Scanner Item</a>
</p><p/>
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#a-simple-example">A Simple Example</a></li>
<li class="level1"><a href="#the-inputs-and-outputs-variables">The <code>inputs</code> and <code>outputs</code> Variables</a></li>
<li class="level1"><a href="#rules-and-product-types">Rules and Product Types</a></li>
<li class="level1"><a href="#rule-properties">Rule Properties</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Rule Item</h1>
<span class="subtitle"></span>
<!-- $$$rule-item.html-description -->
<div class="descr"> <a name="details"></a>
<p>In Qbs, rules create <i>transformers</i> that produce output files from input files. The term <i>transformer</i> refers to a list of <a href="commands.html">commands</a>. These commands are created in a rule's <i>prepare script</i>. They do the actual work, either directly or by executing external commands.</p>
<a name="a-simple-example"></a>
<h2 id="a-simple-example">A Simple Example</h2>
<p>The following rule takes text files and replaces Windows-style line endings with their Unix-style counterparts. We will look at it one piece at a time.</p>
<pre class="cpp">

  Rule {
      multiplex: <span class="keyword">false</span>

</pre>
<p>A <i>multiplex rule</i> creates one transformer that takes all input artifacts with the matching input file tag and creates one or more output artifacts. We are setting the respective property to <code>false</code> here, indicating that we want to create one transformer per input file.</p>
<p><b>Note: </b>This is actually the default, so the above assignment is not required.</p><pre class="cpp">

  inputs: <span class="operator">[</span><span class="string">&quot;txt_input&quot;</span><span class="operator">]</span>

</pre>
<p>Here we are specifying that our rule is interested in input files that have the tag &quot;txt_input&quot;. Such files could be source files, in which case you would tag them using a <a href="group-item.html">Group</a>. Or they could in turn get generated by a different rule, in which case that rule would assign the file tag. The files matching the tag will be available in the prepare script under the name <code>inputs</code> (see <a href="rule-item.html#inputs-and-outputs">The inputs and outputs Variables</a>).</p>
<pre class="cpp">

  Artifact {
      filePath: input<span class="operator">.</span>fileName <span class="operator">+</span> <span class="string">&quot;.out&quot;</span>
      fileTags: <span class="operator">[</span><span class="string">&quot;txt_output&quot;</span><span class="operator">]</span>
  }

</pre>
<p>Here we are specifying that for every input file, we want to create one output file whose name is the same as the input file, but with an additional extension. Because we are giving a relative path, Qbs will prepend that path by the product's build directory.</p>
<p>In addition, we tell Qbs that the output files should get the file tag &quot;txt_output&quot;. This enables other rules to use these files as inputs. You must always assign suitable file tags to your output artifacts, or the rule will not be run. See <a href="rule-item.html#rules-and-product-types">Rules and Product Types</a> for details.</p>
<p>If you want to create more than one output file per input file, you simply provide multiple <code>Artifact</code> items. The set of output artifacts will be available in the prepare script under the name <code>outputs</code> (see <a href="rule-item.html#inputs-and-outputs">The inputs and outputs Variables</a>).</p>
<pre class="cpp">

      prepare: {
          var cmd <span class="operator">=</span> <span class="keyword">new</span> JavaScriptCommand();
          cmd<span class="operator">.</span>description <span class="operator">=</span> input<span class="operator">.</span>fileName <span class="operator">+</span> <span class="string">&quot;-&gt;&quot;</span> <span class="operator">+</span> output<span class="operator">.</span>fileName;
          cmd<span class="operator">.</span>highlight <span class="operator">=</span> <span class="string">&quot;codegen&quot;</span>;
          cmd<span class="operator">.</span>sourceCode <span class="operator">=</span> function() {
              var file <span class="operator">=</span> <span class="keyword">new</span> TextFile(input<span class="operator">.</span>filePath);
              var content <span class="operator">=</span> file<span class="operator">.</span>readAll();
              file<span class="operator">.</span>close()
              content <span class="operator">=</span> content<span class="operator">.</span>replace(<span class="operator">/</span>\r\n<span class="operator">/</span>g<span class="operator">,</span> <span class="string">&quot;\n&quot;</span>);
              file <span class="operator">=</span> <span class="keyword">new</span> TextFile(output<span class="operator">.</span>filePath<span class="operator">,</span> TextFile<span class="operator">.</span>WriteOnly);
              file<span class="operator">.</span>write(content);
              file<span class="operator">.</span>close();
          }
          <span class="keyword">return</span> <span class="operator">[</span>cmd<span class="operator">]</span>;
      }
  }

</pre>
<p>The prepare script shown above puts everything together by creating the command that does the actual transformation of the file contents, employing the help of the <a href="jsextension-textfile.html">TextFile</a> class.</p>
<p>As you can see, the return value is an array, meaning you can provide several commands to implement the rule's functionality. For instance, if we had provided two <code>Artifact</code> items, we might have also provided two commands, each of them creating one output file.</p>
<p>For the <code>input</code> and <code>output</code> variables used in the code, see the next section.</p>
<a name="inputs-and-outputs"></a><a name="the-inputs-and-outputs-variables"></a>
<h2 id="the-inputs-and-outputs-variables">The <code>inputs</code> and <code>outputs</code> Variables</h2>
<p>We already mentioned that the input and output artifacts are available in the prepare script via the variables <code>inputs</code> and <code>outputs</code>, respectively. These variables are JavaScript objects whose property keys are file tags and whose property values are lists of objects representing the artifacts matching these tags. In our example, the <code>inputs</code> variable has a single property <code>txt_input</code>, whose value is a list with one element. Similarly, the <code>outputs</code> variable also has one single property <code>txt_output</code>, again with a list containing one element.</p>
<p>The actual artifact objects have the following properties:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Property</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><code>baseName</code></td><td >The file name without any extension.</td></tr>
<tr valign="top" class="even"><td ><code>completeBaseName</code></td><td >The file name without the last extension.</td></tr>
<tr valign="top" class="odd"><td ><code>fileName</code></td><td >The name of the file (that is, <code>filePath</code> without any directory components).</td></tr>
<tr valign="top" class="even"><td ><code>filePath</code></td><td >The full file path.</td></tr>
<tr valign="top" class="odd"><td ><code>fileTags</code></td><td >The list of the artifact's file tags.</td></tr>
</table></div>
<p>The artifact object contains a property for every module that is used in the product. That can be used to access the module's properties. For instance, for an artifact in a C++ product, <code>artifact.cpp.defines</code> is the list of defines that will be passed when compiling the respective file.</p>
<p>But what about the variables <code>input</code> and <code>output</code> that appeared in our example? These are simply convenience variables which are available in the case that the <code>inputs</code> and <code>outputs</code> variables contain only one artifact, respectively. So in our example, instead of <code>input</code> we also could have written <code>inputs.txt_input[0]</code>, which is considerably more verbose.</p>
<a name="rules-and-product-types"></a>
<h2 id="rules-and-product-types">Rules and Product Types</h2>
<p>It is important to know that when figuring out which rules to execute, Qbs starts at the product type and then looks for a way to produce artifacts with matching file tags from source files, using a chain of rules that are connected by their respective input and output tags. For instance, consider this simple C++ project:</p>
<pre class="cpp">

  Product {
      type: <span class="operator">[</span><span class="string">&quot;application&quot;</span><span class="operator">]</span>
      Depends { name: <span class="string">&quot;cpp&quot;</span> }
      files: <span class="operator">[</span><span class="string">&quot;main.cpp&quot;</span><span class="operator">]</span>
  }

</pre>
<p>Here's how this product is built:</p>
<ol class="1" type="1"><li>Qbs looks for a rule that can produce artifacts with the file tag <code>&quot;application&quot;</code>. Such a rule is found in the <code>cpp</code> module (namely, the rule that invokes the linker).</li>
<li>Since the rule found in the previous step takes inputs of type <code>&quot;obj&quot;</code>, Qbs now looks for a rule that produces artifacts of that type. Again, such a rule is found in the <code>cpp</code> module (the rule that runs the compiler).</li>
<li>The rule found in the previous step takes inputs of type <code>&quot;cpp&quot;</code>. No rule is found that creates such artifacts, but we do have a source file with a matching type (because the <code>cpp</code> module contains a <a href="filetagger-item.html">FileTagger</a> which attached that type to <code>&quot;main.cpp&quot;</code> due to its file extension).</li>
<li>Now that there is a chain of rules leading from a source file tag to the product type, the commands of these rules are executed one after the other until we end up with our executable.</li>
</ol>
<a name="rule-properties"></a>
<h2 id="rule-properties">Rule Properties</h2>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Property</th><th >Type</th><th >Default</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td >multiplex</td><td >bool</td><td >false</td><td >Determines whether this is a multiplex rule.</td></tr>
<tr valign="top" class="even"><td >inputs</td><td >string list</td><td >undefined</td><td >File tags the input artifacts must match. All output artifacts will depend on all artifacts in the product with the given input file tags. Also these artifacts are available in the inputs variable of the prepare script.</td></tr>
<tr valign="top" class="odd"><td >auxiliaryInputs</td><td >string list</td><td >undefined</td><td >A list of file tags. This rule will be dependent on every other rule that produces artifacts that are compatible with <i>auxiliaryInputs</i>. Unlike <i>inputs</i>, the property <i>auxiliaryInputs</i> has no effect on the content of the <i>inputs</i> variable in the <i>prepare</i> script. All rules in this product and rules of product dependencies that produce target artifacts are considered.</td></tr>
<tr valign="top" class="even"><td >excludedAuxiliaryInputs</td><td >string list</td><td >undefined</td><td >A list of file tags. Connections to rules that produce these file tags are prevented. This property has no effect on the content of the <i>inputs</i> variable in the <i>prepare</i> script.</td></tr>
<tr valign="top" class="odd"><td >inputsFromDependencies</td><td >string list</td><td >undefined</td><td >File tags the artifacts of product dependencies must match. For example, the product <i>foo</i> might appear as follows in the current product:<pre class="cpp">

  Depends {
      name: <span class="string">&quot;foo&quot;</span>
  }

</pre>
<p>All artifacts of <i>foo</i> that match the given file tags will appear in the <i>inputs</i> variable of the prepare script.</p>
</td></tr>
<tr valign="top" class="even"><td >outputArtifacts</td><td >array of objects</td><td >undefined</td><td >An array of output artifacts, specified as JavaScript objects. Example:<pre class="cpp">

  outputArtifacts: <span class="operator">[</span>{
      filePath: <span class="string">&quot;myfile.cpp&quot;</span><span class="operator">,</span>
      fileTags: <span class="operator">[</span><span class="string">&quot;cpp&quot;</span><span class="operator">]</span><span class="operator">,</span>
      cpp: { cxxLanguageVersion: <span class="string">&quot;c++11&quot;</span> }
  }<span class="operator">]</span>

</pre>
<p>For a description of the possible properties, see the documentation of the <a href="artifact-item.html">Artifact item</a>. Output artifacts can be specified either by <code>Rule.outputArtifacts</code> or by <code>Artifact</code> items. Use <code>Rule.outputArtifacts</code> if the set of outputs is not fixed but dependent on the input's content. If no file tags are provided, Qbs will apply all <a href="filetagger-item.html">file taggers</a> known in the current context to the output file name. The user may set the property <code>explicitlyDependsOn</code> on artifact objects, which is similar to <code>Rule.explicitlyDependsOn</code>.</p>
</td></tr>
<tr valign="top" class="odd"><td >outputFileTags</td><td >string list</td><td >undefined</td><td >If output artifacts are specified by <code>Rule.outputArtifacts</code>, then <code>Rule.outputFileTags</code> must be a list of file tags the rule potentially produces.</td></tr>
<tr valign="top" class="even"><td >condition</td><td >bool</td><td >true</td><td >If true, the rule is enabled, otherwise it does nothing.</td></tr>
<tr valign="top" class="odd"><td >explicitlyDependsOn</td><td >string list</td><td >undefined</td><td >Each artifact that matches the file tags in <i>explicitlyDependsOn</i> is added to the dependencies of each output node. All artifacts in the current product and target artifact of products that this product depends on are considered.</td></tr>
<tr valign="top" class="even"><td >prepare</td><td >script</td><td >undefined</td><td >Script that prepares the commands to transform the inputs to outputs. The code in this script is treated as a function with the signature <code>function(project, product, inputs, outputs, input, output, explicitlyDependsOn)</code>. The argument <code>input</code> is <code>undefined</code> if there's more than one input artifact for this rule. Similarly, <code>output</code> is only defined if there's exactly one output artifact.</td></tr>
<tr valign="top" class="odd"><td >requiresInputs</td><td >bool</td><td ><code>true</code> if the rule declares any inputs, <code>false</code> otherwise</td><td >Specifies whether a rule's commands should be created even if no inputs are available. Enabling this property can be useful in cases where you potentially have input files, but it is possible that there are none and you want to create the output file in any case.</td></tr>
<tr valign="top" class="even"><td >alwaysRun</td><td >bool</td><td >false</td><td >If true, the rule's commands are always executed, even if all output artifacts are up to date.</td></tr>
</table></div>
</div>
<!-- @@@rule-item.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="propertyoptions-item.html">PropertyOptions Item</a>
<span class="naviSeparator">  &#9702;  </span>
<a class="nextPage" href="scanner-item.html">Scanner Item</a>
</p>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2017 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
