<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- iplugin.cpp -->
  <title>IPlugin Class | Extending Qt Creator Manual</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="extending-index.html">Extending Qt Creator Manual</a></td><td >IPlugin</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Extending Qt Creator Manual 4.5.0</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#plugin-specification">Plugin Specification</a></li>
<li class="level2"><a href="#plugin-implementation">Plugin Implementation</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">IPlugin Class</h1>
<span class="small-subtitle">(<a href="extensionsystem-iplugin.html">ExtensionSystem::IPlugin</a>)<br/></span>
<!-- $$$IPlugin-brief -->
<p>The <a href="extensionsystem-iplugin.html">IPlugin</a> class is the base class for all plugins. <a href="#details">More...</a></p>
<!-- @@@IPlugin -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;IPlugin&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="projectexplorer-projectexplorerplugin.html">ProjectExplorer::ProjectExplorerPlugin</a> and <a href="vcsbase-vcsbaseplugin.html">VcsBase::VcsBasePlugin</a></p>
</td></tr></table></div><ul>
<li><a href="extensionsystem-iplugin-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#ShutdownFlag-enum">ShutdownFlag</a></b> { SynchronousShutdown, AsynchronousShutdown }</td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual ShutdownFlag </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#aboutToShutdown">aboutToShutdown</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#addAutoReleasedObject">addAutoReleasedObject</a></b>(QObject *<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#addObject">addObject</a></b>(QObject *<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QList&lt;QObject *&gt; </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#createTestObjects">createTestObjects</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#delayedInitialize">delayedInitialize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#extensionsInitialized">extensionsInitialized</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#initialize">initialize</a></b>(const QStringList &amp;<i>arguments</i>, QString *<i>errorString</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> PluginSpec *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#pluginSpec">pluginSpec</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QObject *</td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#remoteCommand">remoteCommand</a></b>(const QStringList &amp;<i>options</i>, const QString &amp;<i>workingDirectory</i>, const QStringList &amp;<i>arguments</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#removeObject">removeObject</a></b>(QObject *<i>obj</i>)</td></tr>
</table></div>
<a name="signals"></a>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="extensionsystem-iplugin.html#asynchronousShutdownFinished">asynchronousShutdownFinished</a></b>()</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$IPlugin-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The <a href="extensionsystem-iplugin.html">IPlugin</a> class is the base class for all plugins.</p>
<p>The <a href="extensionsystem-iplugin.html">IPlugin</a> class is an abstract class that must be implemented once for each plugin. A plugin consists of two parts: A description file, and a library that at least contains the <a href="extensionsystem-iplugin.html">IPlugin</a> implementation.</p>
<a name="plugin-specification"></a>
<h3 >Plugin Specification</h3>
<p>A plugin needs to provide a plugin specification file in addition to the actual plugin library, so the plugin manager can find the plugin, resolve its dependencies, and load it. For more information, see Plugin Specifications.</p>
<a name="plugin-implementation"></a>
<h3 >Plugin Implementation</h3>
<p>Plugins must provide one implementation of the <a href="extensionsystem-iplugin.html">IPlugin</a> class, located in a library that matches the <code>name</code> attribute given in their XML description. The <a href="extensionsystem-iplugin.html">IPlugin</a> implementation must be exported and made known to Qt's plugin system, using the <code>Q_PLUGIN_METADATA</code> macro with an IID set to <code>&quot;org.qt-project.Qt.QtCreatorPlugin&quot;</code>.</p>
<p>After the plugins' XML files have been read, and dependencies have been found, the plugin loading is done in three phases:</p>
<ol class="1" type="1"><li>All plugin libraries are loaded in <i>root-to-leaf</i> order of the dependency tree.</li>
<li>All plugins' initialize functions are called in <i>root-to-leaf</i> order of the dependency tree. This is a good place to put objects in the plugin manager's object pool.</li>
<li>All plugins' <a href="extensionsystem-iplugin.html#extensionsInitialized">extensionsInitialized</a> functions are called in <i>leaf-to-root</i> order of the dependency tree. At this point, plugins can be sure that all plugins that depend on this plugin have been initialized completely (implying that they have put objects in the object pool, if they want that during the initialization sequence).</li>
</ol>
<p>If library loading or initialization of a plugin fails, all plugins that depend on that plugin also fail.</p>
<p>Plugins have access to the plugin manager (and its object pool) via the <a href="extensionsystem-pluginmanager.html#instance">PluginManager::instance</a>() function.</p>
</div>
<!-- @@@IPlugin -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ShutdownFlag$$$SynchronousShutdown$$$AsynchronousShutdown -->
<h3 class="fn" id="ShutdownFlag-enum"><a name="ShutdownFlag-enum"></a>enum IPlugin::<span class="name">ShutdownFlag</span></h3>
<!-- @@@ShutdownFlag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$aboutToShutdown[overload1]$$$aboutToShutdown -->
<h3 class="fn" id="aboutToShutdown"><a name="aboutToShutdown"></a><code>[virtual] </code><span class="type"><a href="extensionsystem-iplugin.html#ShutdownFlag-enum">ShutdownFlag</a></span> IPlugin::<span class="name">aboutToShutdown</span>()</h3>
<p>Called during a shutdown sequence in the same order as initialization before the plugins get deleted in reverse order.</p>
<p>This function should be used to disconnect from other plugins, hide all UI, and optimize shutdown in general. If a plugin needs to delay the real shutdown for a while, for example if it needs to wait for external processes to finish for a clean shutdown, the plugin can return <a href="extensionsystem-iplugin.html#ShutdownFlag-enum">IPlugin::AsynchronousShutdown</a> from this function. This will keep the main event loop running after the aboutToShutdown() sequence has finished, until all plugins requesting <a href="extensionsystem-iplugin.html#ShutdownFlag-enum">AsynchronousShutdown</a> have sent the <a href="extensionsystem-iplugin.html#asynchronousShutdownFinished">asynchronousShutdownFinished</a>() signal.</p>
<p>The default implementation of this function does nothing and returns <a href="extensionsystem-iplugin.html#ShutdownFlag-enum">IPlugin::SynchronousShutdown</a>.</p>
<p>Returns <a href="extensionsystem-iplugin.html#ShutdownFlag-enum">IPlugin::AsynchronousShutdown</a> if the plugin needs to perform asynchronous actions before performing the shutdown.</p>
<p><b>See also </b><a href="extensionsystem-iplugin.html#asynchronousShutdownFinished">asynchronousShutdownFinished</a>().</p>
<!-- @@@aboutToShutdown -->
<!-- $$$addAutoReleasedObject[overload1]$$$addAutoReleasedObjectQObject* -->
<h3 class="fn" id="addAutoReleasedObject"><a name="addAutoReleasedObject"></a><span class="type">void</span> IPlugin::<span class="name">addAutoReleasedObject</span>(<span class="type">QObject</span> *<i>obj</i>)</h3>
<p>Convenience function for registering <i>obj</i> in the plugin manager's plugin pool. Usually, registered objects must be removed from the object pool and deleted by hand. Objects added to the pool via addAutoReleasedObject are automatically removed and deleted in reverse order of registration when the <a href="extensionsystem-iplugin.html">IPlugin</a> instance is destroyed.</p>
<p><b>See also </b><a href="extensionsystem-pluginmanager.html#addObject">PluginManager::addObject</a>().</p>
<!-- @@@addAutoReleasedObject -->
<!-- $$$addObject[overload1]$$$addObjectQObject* -->
<h3 class="fn" id="addObject"><a name="addObject"></a><span class="type">void</span> IPlugin::<span class="name">addObject</span>(<span class="type">QObject</span> *<i>obj</i>)</h3>
<p>Convenience function that registers <i>obj</i> in the plugin manager's plugin pool by just calling <a href="extensionsystem-pluginmanager.html#addObject">PluginManager::addObject</a>().</p>
<!-- @@@addObject -->
<!-- $$$asynchronousShutdownFinished[overload1]$$$asynchronousShutdownFinished -->
<h3 class="fn" id="asynchronousShutdownFinished"><a name="asynchronousShutdownFinished"></a><code>[signal] </code><span class="type">void</span> IPlugin::<span class="name">asynchronousShutdownFinished</span>()</h3>
<p>Sent by the plugin implementation after a asynchronous shutdown is ready to proceed with the shutdown sequence.</p>
<p><b>See also </b><a href="extensionsystem-iplugin.html#aboutToShutdown">aboutToShutdown</a>().</p>
<!-- @@@asynchronousShutdownFinished -->
<!-- $$$createTestObjects[overload1]$$$createTestObjects -->
<h3 class="fn" id="createTestObjects"><a name="createTestObjects"></a><code>[virtual] </code><span class="type">QList</span>&lt;<span class="type">QObject</span> *&gt; IPlugin::<span class="name">createTestObjects</span>() const</h3>
<p>Returns objects that are meant to be passed on to QTest::qExec().</p>
<p>This function will be called if the user starts Qt Creator with '-test PluginName' or '-test all'.</p>
<p>The ownership of returned objects is transferred to caller.</p>
<!-- @@@createTestObjects -->
<!-- $$$delayedInitialize[overload1]$$$delayedInitialize -->
<h3 class="fn" id="delayedInitialize"><a name="delayedInitialize"></a><code>[virtual] </code><span class="type">bool</span> IPlugin::<span class="name">delayedInitialize</span>()</h3>
<p>Called after all plugins' <a href="extensionsystem-iplugin.html#extensionsInitialized">IPlugin::extensionsInitialized</a>() function has been called, and after the IPlugin::delayedInitialize() function of plugins that depend on this plugin have been called.</p>
<p>The plugins' delayedInitialize() functions are called after the application is already running, with a few milliseconds delay to application startup, and between individual delayedInitialize function calls. To avoid unnecessary delays, a plugin should return true from the function if it actually implements it, to indicate that the next plugins' delayedInitialize() call should be delayed a few milliseconds to give input and paint events a chance to be processed.</p>
<p>This function can be used if a plugin needs to do non-trivial setup that doesn't necessarily need to be done directly at startup, but still should be done within a short time afterwards. This can decrease the felt plugin/application startup time a lot, with very little effort.</p>
<p><b>See also </b><a href="extensionsystem-iplugin.html#initialize">initialize</a>() and <a href="extensionsystem-iplugin.html#extensionsInitialized">extensionsInitialized</a>().</p>
<!-- @@@delayedInitialize -->
<!-- $$$extensionsInitialized[overload1]$$$extensionsInitialized -->
<h3 class="fn" id="extensionsInitialized"><a name="extensionsInitialized"></a><code>[pure virtual] </code><span class="type">void</span> IPlugin::<span class="name">extensionsInitialized</span>()</h3>
<p>Called after the <a href="extensionsystem-iplugin.html#initialize">IPlugin::initialize</a>() function has been called, and after both the <a href="extensionsystem-iplugin.html#initialize">IPlugin::initialize</a>() and IPlugin::extensionsInitialized() functions of plugins that depend on this plugin have been called.</p>
<p>In this function, the plugin can assume that plugins that depend on this plugin are fully 'up and running'. It is a good place to look in the plugin manager's object pool for objects that have been provided by dependent plugins.</p>
<p><b>See also </b><a href="extensionsystem-iplugin.html#initialize">initialize</a>() and <a href="extensionsystem-iplugin.html#delayedInitialize">delayedInitialize</a>().</p>
<!-- @@@extensionsInitialized -->
<!-- $$$initialize[overload1]$$$initializeconstQStringList&QString* -->
<h3 class="fn" id="initialize"><a name="initialize"></a><code>[pure virtual] </code><span class="type">bool</span> IPlugin::<span class="name">initialize</span>(const <span class="type">QStringList</span> &amp;<i>arguments</i>, <span class="type">QString</span> *<i>errorString</i>)</h3>
<p>Called after the plugin has been loaded and the <a href="extensionsystem-iplugin.html">IPlugin</a> instance has been created.</p>
<p>The initialize functions of plugins that depend on this plugin are called after the initialize function of this plugin has been called. Plugins should initialize their internal state in this function. Returns if initialization of successful. If it wasn't successful, the <i>errorString</i> should be set to a user-readable message describing the reason.</p>
<p><b>See also </b><a href="extensionsystem-iplugin.html#extensionsInitialized">extensionsInitialized</a>() and <a href="extensionsystem-iplugin.html#delayedInitialize">delayedInitialize</a>().</p>
<!-- @@@initialize -->
<!-- $$$pluginSpec[overload1]$$$pluginSpec -->
<h3 class="fn" id="pluginSpec"><a name="pluginSpec"></a><span class="type"><a href="extensionsystem-pluginspec.html">PluginSpec</a></span> *IPlugin::<span class="name">pluginSpec</span>() const</h3>
<p>Returns the <a href="extensionsystem-pluginspec.html">PluginSpec</a> corresponding to this plugin. This is not available in the constructor.</p>
<!-- @@@pluginSpec -->
<!-- $$$remoteCommand[overload1]$$$remoteCommandconstQStringList&constQString&constQStringList& -->
<h3 class="fn" id="remoteCommand"><a name="remoteCommand"></a><code>[virtual] </code><span class="type">QObject</span> *IPlugin::<span class="name">remoteCommand</span>(const <span class="type">QStringList</span> &amp;<i>options</i>, const <span class="type">QString</span> &amp;<i>workingDirectory</i>, const <span class="type">QStringList</span> &amp;<i>arguments</i>)</h3>
<!-- @@@remoteCommand -->
<!-- $$$removeObject[overload1]$$$removeObjectQObject* -->
<h3 class="fn" id="removeObject"><a name="removeObject"></a><span class="type">void</span> IPlugin::<span class="name">removeObject</span>(<span class="type">QObject</span> *<i>obj</i>)</h3>
<p>Convenience function that unregisters <i>obj</i> from the plugin manager's plugin pool by just calling <a href="extensionsystem-pluginmanager.html#removeObject">PluginManager::removeObject</a>().</p>
<!-- @@@removeObject -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2017 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
